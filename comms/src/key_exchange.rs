use std::io;
#[allow(unused_imports)]
use tracing::{debug, error, info, instrument, span, trace, warn, Level};
use ate_crypto::KeySize;
use ate_crypto::PrivateEncryptKey;
use ate_crypto::EncryptKey;
use ate_crypto::InitializationVector;
use ate_crypto::PublicEncryptKey;

use super::protocol::MessageProtocolApi;
use super::CertificateValidation;

pub async fn mesh_key_exchange_sender(
    proto: &mut (dyn MessageProtocolApi + Send + Sync + 'static),
    key_size: KeySize,
    validation: CertificateValidation,
) -> io::Result<EncryptKey> {
    trace!("negotiating {}bit shared secret", key_size);

    // Generate the encryption keys
    let sk1 = PrivateEncryptKey::generate(key_size);
    let pk1 = sk1.as_public_key();
    let pk1_bytes = pk1.pk();

    // Send our public key to the other side
    trace!("client sending its public key (and strength)");
    proto.write_with_fixed_32bit_header(pk1_bytes, false).await?;

    // Receive one half of the secret that was just generated by the other side
    let iv1_bytes = proto.read_with_fixed_32bit_header().await?;
    let iv1 = InitializationVector::from(iv1_bytes);
    let ek1 = match sk1.decapsulate(&iv1) {
        Some(a) => a,
        None => {
            return Err(io::Error::new(io::ErrorKind::ConnectionRefused, "Failed to decapsulate the encryption key from the received initialization vector."));
        }
    };
    trace!("client received the servers half of the shared secret");

    // Receive the public key from the other side (which we will use in a sec)
    let pk2_bytes = proto.read_with_fixed_32bit_header().await?;
    trace!("client received the servers public key");
    let pk2 = match PublicEncryptKey::from_bytes(pk2_bytes) {
        Some(a) => a,
        None => {
            return Err(io::Error::new(io::ErrorKind::ConnectionRefused, "Failed to receive a public key from the other side."));
        }
    };

    // Validate the public key against our validation rules
    if validation.validate(&pk2.hash()) == false {
        return Err(io::Error::new(io::ErrorKind::ConnectionRefused, "The server certificate failed the clients validation check."));
    }

    // Generate one half of the secret and send the IV so the other side can recreate it
    let (iv2, ek2) = pk2.encapsulate();
    proto.write_with_fixed_32bit_header(&iv2.bytes[..], false).await?;
    trace!("client sending its half of the shared secret");

    // Merge the two halfs to make one shared secret
    trace!("client shared secret established");
    Ok(EncryptKey::xor(&ek1, &ek2))
}

pub async fn mesh_key_exchange_receiver(
    proto: &mut (dyn MessageProtocolApi + Send + Sync + 'static),
    server_key: PrivateEncryptKey,
) -> io::Result<EncryptKey> {
    trace!("negotiating {}bit shared secret", server_key.size());

    // Receive the public key from the caller side (which we will use in a sec)
    let pk1_bytes = proto.read_with_fixed_32bit_header().await?;
    trace!("server received clients public key");
    let pk1 = match PublicEncryptKey::from_bytes(pk1_bytes) {
        Some(a) => a,
        None => {
            return Err(io::Error::new(io::ErrorKind::ConnectionRefused, "Failed to receive a valid public key from the sender."));
        }
    };

    // Generate one half of the secret and send the IV so the other side can recreate it
    let (iv1, ek1) = pk1.encapsulate();
    trace!("server sending its half of the shared secret");
    proto.write_with_fixed_32bit_header(&iv1.bytes[..], true).await?;

    let sk2 = server_key;
    let pk2 = sk2.as_public_key();
    let pk2_bytes = pk2.pk();

    // Send our public key to the other side
    trace!("server sending its public key");
    proto.write_with_fixed_32bit_header(pk2_bytes, false).await?;

    // Receive one half of the secret that was just generated by the other side
    let iv2_bytes = proto.read_with_fixed_32bit_header().await?;
    let iv2 = InitializationVector::from(iv2_bytes);
    let ek2 = match sk2.decapsulate(&iv2) {
        Some(a) => a,
        None => {
            return Err(io::Error::new(io::ErrorKind::ConnectionRefused, "Failed to receive a public key from the other side."));
        }
    };
    trace!("server received client half of the shared secret");

    // Merge the two halfs to make one shared secret
    trace!("server shared secret established");
    Ok(EncryptKey::xor(&ek1, &ek2))
}
